#!/usr/bin/env python3

# rpcgenerate
#   - generates proxies and stubs for idl files
#   - usage: rpcgenerate [-h] idlfiles [idlfiles ...]
#   - output: <name>.proxy.cpp, <name>.stub.cpp
#
#   - by: Justin Jo and Charles Wan
#
# NEEDSWORK:
#   -
#
# Notes:
#   - this program uses python3

import argparse
import itertools
import json
import os
import re
import subprocess
import sys


##### MISCELLANEOUS FUNCTIONS

# parse_args
#   - parse cmd line arguments
#   - returns: argparse.Namespace, [argname=argvalue, ...]

def parse_args():
    parser = argparse.ArgumentParser(
        description='Generate proxies and stubs from idl files',
    )
    parser.add_argument(
        'idlfiles',
        type=str,
        nargs='+',
        help='an idl file',
    )

    args = parser.parse_args()
    return args


# prints out program usage
def usage():
    print('usage: {} [-h] idlfiles [idlfiles...]'.format(sys.arv[0]))


# isfile
#   - returns:
#       - true, if file fname exists and is readable
#       - false, otherwise

def isfile(fname):
    return os.path.isfile(fname) and os.access(fname, os.R_OK)


# get_file_prefix
#   - for an idl file <idlname>.idl, extracts and returns idlname
#   - if idlfile is does not end with .idl, it is assumed not to be an idl
#     file, and None is returned

def get_file_prefix(idlfile):
    m = re.search('(.+).idl', idlfile)
    return m.group(1) if m else None


# clean_type
#   - some complex types in the idl's json format have extra unnecessary chars
#   - clean_type removes them and returns the cleaned type
#
# cleaned characters:
#   - leading '__'

def clean_type(ty):
    m = re.search('__(\S+)', ty)
    return m.groups()[0] if m else ty


##### IDL PROCESSING FUNCTIONS

### SHARED

# generate_funcheader
#   - generates a header for a c++ function using a dict representing a
#     functions type
#   - header format: 'returntype funcname (argtype argnamem, ...)'
#   - note: curly braces are not included

def generate_funcheader(funcname, funcdict):
    returntype = clean_type(funcdict['return_type'])
    args = [ # iterate over pairs of arguments, organize into list of arg strs
        (clean_type(p['type']) + ' ' + p['name'])
        for p in funcdict['arguments']
    ]
    return returntype + ' ' + funcname + ' (' + ', '.join(args) + ')'


# generate_vardecl
#   - generates a c++ line declaring a variable with a given type
#   - declaration format: 'vartype varname([digit])*'
#   - note: terminating semi colon is NOT included

def generate_vardecl(vartype, varname):
    vartype = clean_type(vartype)

    if '[' in vartype and ']' in vartype: # array type
        m = re.search('([^\[\]]+)([\[\]0-9]+)', vartype)
        vartype = m.groups()[0]
        varname += m.groups()[1]

    return vartype + ' ' + varname


# generate_readcheck
#   - generates a c++ func that reads from a socket and verifies that exactly
#     buflen bytes were read
#   - returns 0 if correct number of bytes read, -1 otherwise

def generate_readcheck(prefix, is_stub):
    sock = 'RPC' + ('STUB' if is_stub else 'PROXY') + 'SOCKET'
    return (
        'void readAndCheck(char *buf, ssize_t buflen) {\n'
        '  ssize_t readlen = ' + sock + '->read(buf, buflen);\n'
        '  if (readlen != buflen) {\n'
        '    c150debug->printf(\n'
        '      C150RPCDEBUG,\n'
        '      "' + prefix + '.stub: expected %d bytes, but got %d",\n'
        '      buflen, readlen\n'
        '    );\n'
        '    if (' + sock + '->eof()) {\n'
        '      c150debug->printf(\n'
        '        C150RPCDEBUG,\n'
        '        "' + prefix + '.stub: EOF signaled on input"\n'
        '      );\n'
        '    } else {\n'
        '      throw C150Exception(\n'
        '        "' + prefix + '.stub: unexpected 0 length read without eof"\n'
        '      );\n'
        '    }\n'
        '  }\n'
        '}\n'
    )


# generate_readstring
#   - generates a c++ func that reads a string from a socket
#       - raises an exception if 0 bytes read without eof, or func is not null
#         terminated
# readString args:
#   - s: string reference to read to, will be cleared before read
#   - maxLength: max number of bytes to read to string
#       - if maxLength <= 0, maxLength is assumed to be infinite

def generate_readstring(prefix, is_stub):
    sock = 'RPC' + ('STUB' if is_stub else 'PROXY') + 'SOCKET'
    return (
        'void readString(string &s, int maxLength) {\n'
        '  char lastRead;\n'
        '  int i = 0;\n'
        '\n'
        '  s.clear();\n' # clear to ensure append from beginning
        '\n'
        '  while (maxLength <= 0 || i < maxLength) {\n'
        '    readAndCheck(&lastRead, 1);\n'
        '    s += lastRead;\n'
        '\n'
        "    if (lastRead == '\\0') {\n"
        '      break;\n'
        '    } else {\n'
        '      i++;\n'
        '    }\n'
        '  }\n'
        '\n'
        "  if (lastRead != '\\0') {\n"
        '    throw C150Exception(\n'
        '      "' + prefix + '.stub: method name not null or too long"\n'
        '    );\n'
        '  }\n'
        '}\n'
    )


# generate_shared
#   - generates code shared among both proxy and stub files
#
# args:
#   - prefix [str]: the prefix of the idl file
#   - is_stub [bool]: true if stub, false if proxy
#
# returns: string containing generated code

def generate_shared(prefix, is_stub):
    includes = \
        '#include <cstdio>\n' +\
        '#include <cstring>\n' +\
        '#include <string>\n' +\
        '#include "c150debug.h"\n' +\
        '#include "rpc' + ('stub' if is_stub else 'proxy') + 'helper.h"\n' +\
        '#include "' + prefix + '.idl"\n'
    namespaces = \
        'using namespace std;\n' + \
        'using namespace C150NETWORK;\n'

    shared = [
        includes + namespaces,
        generate_readcheck(prefix, is_stub),
        generate_readstring(prefix, is_stub),
    ]
    return '\n'.join(shared)


### PROXY

# generate_proxy
#   - generates and saves a proxy for a given file
#   - file will be named: <prefix>.proxy.cpp
#
# args:
#   - decls [dict]: idl file contents loaded as json into a python dict
#   - prefix [str]: the prefix of the idl file
#
# returns: n/a

def generate_proxy(decls, prefix):
    pass


### STUB

# generate_badfunc
#   - generates a c++ function that handles a bad function response

def generate_badfunc(prefix):
    return (
        'void _badFunction(string &funcname) {\n'
        '  int errorCode = -1;\n'
        '  c150debug->printf(\n'
        '    C150RPCDEBUG,\n'
        '    "' + prefix + '.stub: received call for nonexistent func %s()",\n'
        '    funcname.c_str()\n'
        '  );\n'
        '  RPCSTUBSOCKET->write((char *)&errorCode, sizeof(errorCode));\n'
        '}\n'
    )


# generate_argreads
#   - for each variable, add the necessary number of reads to fill the variable
#     off the wire
#   - for simple types like void/float, only 1 read is necessary
#   - for array types, for loop to read 1 per element
#   - for structs, we do 1 read per member
#   - if arg types are nested, we nest the number of reads, according to the
#     above
#
# args:
#   - argname [str]: name of argument
#   - argtype [str]: type of argument, should have an entry in typedict
#   - typedict [dict]: dictionary of types
#   - n [int]: number of recursive calls so far, initialized to 0, should not be
#       used by nonrecursive calls
#       - needed to guarantee that iterators in for loops are unique
#
# returns [str]: c++ string of arg reads, or None if invalid type found

BUILTIN_SIZES = {
    'string': None,
    'int': 4,
    'float': 4,
    'void': None,
}

def generate_argreads(argname, argtype, typedict, n=0):
    if argtype in typedict:
        type_of_type = typedict[argtype]['type_of_type']
    else:
        return None # type not found, invalid

    if type_of_type == 'builtin':
        if argtype == 'string':
            return 'readString(' + argname + ', 0);\n' # 0 for infinite length

        else: # should be int/float
            argsize = str(BUILTIN_SIZES[argtype])
            return 'readAndCheck((char *)&(' + argname + '), ' + argsize + ');\n'

    elif type_of_type == 'array':
        # for each level of array, generate a for loop
        iterator = 'i' + str(n)
        arrstr = 'for (int {0} = 0; {0} < {1}; {0}++) {{\n'.format(
            iterator,
            str(typedict[argtype]['element_count']),
        )

        arrstr += generate_argreads(
            argname + '[' + iterator + ']', # including indexing syntax
            typedict[argtype]['member_type'], # element type update
            typedict,
            n + 1,
        )

        return arrstr + '}\n'

    elif type_of_type == 'struct':
        # iterate over each member of the struct and recursively call
        return ''.join([
            generate_argreads(
                argname + '.' + p['name'], # include struct member access
                p['type'], # member type update
                typedict,
                n + 1,
            )
            for p in typedict[argtype]['members']
        ])

    else: # invalid type of type found, bug
        return None


# generate_dispatch
#   - generates the dispatch function for a stub that routes function calls
#

def generate_dispatch(decls, prefix):
    dispatchstr = 'if (!RPCSTUBSOCKET->eof()) {{\n{}{}}}\n'.format(
        '} else '.join([ # check for valid func, then call wrapper
            'if (funcname.compare("' + funcname + '") == 0) {\n_' + funcname + '();\n'
            for funcname in decls['functions'].keys()
        ]),
        '} else {\n_badFunction(funcname);\n}\n' # invalid func, call to badfunc
    )

    return 'void dispatchFunction() {{\n{}\n{}\n{}}}\n'.format(
        generate_vardecl('string', 'funcname') + ';',
        'readString(funcname, 0);\n',
        dispatchstr,
    )


# generate_stubfunc
#   - generates a c++ wrapper function over a func's idl declaration
#   - a wrapper function reads all its arguments off the wire, calls the idl
#     func, and returns its result
#
# args:
#   - funcname [str]: name of the function to write
#       - funcname must exist within decls['functions']
#   - decls [dict]: a 
#   - prefix [str]: the prefix of the idl file
#
# returns [str]:
#   - c++ function as a string

def generate_stubfunc(funcname, decls, prefix):
    funcdict = decls['functions'][funcname] # assumed to exist in decls

    # generate variable/argument declarations, followed by calls to read values
    # from socket
    argstrs = [
        # declaration \ read
        generate_vardecl(p['type'], p['name']) + ';\n' +\
        generate_argreads(p['name'], p['type'], decls['types'])
        for p in funcdict['arguments']
    ]

    # generate line to make call to func, and write the results to socket
    callstr = '{} = {}({});\n'.format(
        generate_vardecl(funcdict['return_type'], 'res'), # var decl to save
        funcname,
        ', '.join([p['name'] for p in funcdict['arguments']]) # args
    )
    # need to add write to socket line, (void)res temp
    callstr += '(void)res;\n'

    return 'void _{}(){{\n{}\n{}}}\n'.format(
        funcname,
        '\n'.join(argstrs), # arg declarations and reads
        callstr,
    )


# generate_stub
#   - generates and saves a stub for a given file
#   - file will be named: <prefix>.stub.cpp
#
# args:
#   - decls [dict]: idl file contents loaded as json into a python dict
#   - prefix [str]: the prefix of the idl file
#
# returns: n/a

def generate_stub(decls, prefix):
    stubfuncs = ''.join([
        generate_stubfunc(funcname, decls, prefix)
        for funcname in decls['functions'].keys()
    ])

    stub_content = [
        generate_shared(prefix, True), # shared with proxy
        generate_badfunc(prefix),
        stubfuncs,
        generate_dispatch(decls, prefix),
    ]

    with open(prefix + '.stub.cpp', 'w+') as f:
        f.write('\n'.join(stub_content))


### GENERATE

# generate
#   - generates and saves a proxy and stub for a given file
#   - if a file does not exist or cannot be opened, an error message is printed
#     and the function terminates
#
# args:
#   - fname [str]: fname, must be of the pattern *.idl
#
# returns: n/a

def generate(fname):
    if not isfile(fname):
        print("error: '{}' does not exist or could not be opened".format(fname))
        return
    else:
        prefix = get_file_prefix(fname) # save prefix for naming things
        if not prefix:
            print("error: '{}' must be named '<prefix>.idl'".format(fname))
            return

    # parse idl declarations into python dictionary
    decls = json.loads(subprocess.check_output(["./idl_to_json", fname])
        .decode('utf-8'))

    # generate files
    generate_proxy(decls, prefix)
    generate_stub(decls, prefix)


##### MAIN

def main():
    args = parse_args()

    # temp
    for f in args.idlfiles:
        generate(f)
    # temp


if __name__ == '__main__':
    main()
