#!/usr/bin/env python3

# rpcgenerate
#   - generates proxies and stubs for idl files
#   - usage: rpcgenerate [-h] idlfiles [idlfiles ...]
#   - output: <name>.proxy.cpp, <name>.stub.cpp
#
#   - by: Justin Jo and Charles Wan
#
# NEEDSWORK:
#   -
#
# Notes:
#   - this program uses python3

import argparse
import json
import os
import re
import subprocess
import sys


##### MISCELLANEOUS FUNCTIONS

# parse_args
#   - parse cmd line arguments
#   - returns: argparse.Namespace, [argname=argvalue, ...]

def parse_args():
    parser = argparse.ArgumentParser(
        description='Generate proxies and stubs from idl files',
    )
    parser.add_argument(
        'idlfiles',
        type=str,
        nargs='+',
        help='an idl file',
    )

    args = parser.parse_args()
    return args


# prints out program usage
def usage():
    print('usage: {} [-h] idlfiles [idlfiles...]'.format(sys.arv[0]))


# isfile
#   - returns:
#       - true, if file fname exists and is readable
#       - false, otherwise

def isfile(fname):
    return os.path.isfile(fname) and os.access(fname, os.R_OK)


# get_file_prefix
#   - for an idl file <idlname>.idl, extracts and returns idlname
#   - if idlfile is does not end with .idl, it is assumed not to be an idl
#     file, and None is returned

def get_file_prefix(idlfile):
    m = re.search('(.+).idl', idlfile)
    return m.group(1) if m else None


##### IDL PROCESSING FUNCTIONS

### SHARED

# generate_readcheck
#   - generates a c++ func that reads from a socket and verifies that exactly
#     buflen bytes were read
#   - returns 0 if correct number of bytes read, -1 otherwise

def generate_readcheck(is_stub):
    sock = 'RPC' + ('STUB' if is_stub else 'PROXY') + 'SOCKET'
    return (
        'int readAndCheck(char *buf, ssize_t buflen) {\n'
        '  return ' + sock + '->read(buf, buflen) != buflen ? -1 : 0;\n'
        '}\n'
    )


# generate_readstring
#   - generates a c++ func that reads a string from a socket
#       - raises an exception if 0 bytes read without eof, or func is not null
#         terminated
# readString args:
#   - s: string reference to read to, will be cleared before read
#   - maxLength: max number of bytes to read to string
#       - if maxLength <= 0, maxLength is assumed to be infinite

def generate_readstring(prefix, is_stub):
    sock = 'RPC' + ('STUB' if is_stub else 'PROXY') + 'SOCKET'
    return (
        'void readString(string &s, int maxLength) {\n'
        '  char lastRead;\n'
        '  int i = 0;\n'
        '\n'
        '  s.clear();\n'
        '\n'
        '  while (maxLength <= 0 || i < maxLength) {\n'
        '    if (' + sock + '->read(&lastRead, 1) == 0) {\n'
        '      c150debug->printf(\n'
        '        C150RPCDEBUG,\n'
        '        "' + prefix + '.stub: read zero length msg, checking EOF"\n'
        '      );\n'
        '      if (RPCSTUBSOCKET->eof()) {\n'
        '        c150debug->printf(\n'
        '          C150RPCDEBUG,\n'
        '          "' + prefix + '.stub: EOF signaled on input"\n'
        '        );\n'
        '      } else {\n'
        '        throw C150Exception(\n'
        '          "' + prefix + '.stub: unexpected 0 length read without eof"\n'
        '        );\n'
        '      }\n'
        '    } else {\n'
        '      s += lastRead;\n'
        '    }\n'
        '\n'
        "    if (lastRead == '\\0') {\n"
        '      break;\n'
        '    } else {\n'
        '      i++;\n'
        '    }\n'
        '  }\n'
        '\n'
        "  if (lastRead != '\\0') {\n"
        '    throw C150Exception(\n'
        '      "' + prefix + '.stub: method name not null or too long"\n'
        '    );\n'
        '  }\n'
        '}\n'
    )


# generate_shared
#   - generates code shared among both proxy and stub files
#
# args:
#   - prefix [str]: the prefix of the idl file
#   - is_stub [bool]: true if stub, false if proxy
#
# returns: string containing generated code

def generate_shared(prefix, is_stub):
    includes = \
        '#include "' + prefix + '.idl"\n' + \
        '#include "rpc' + ('stub' if is_stub else 'proxy') + 'helper.h"\n' + \
        '#include <cstdio>\n' + \
        '#include <cstring>\n' + \
        '#include <string>\n' + \
        '#include "c150debug.h"\n'
    namespaces = \
        'using namespace std;\n' + \
        'using namespace C150NETWORK;\n'

    shared = [
        includes + namespaces,
        generate_readcheck(is_stub),
        generate_readstring(prefix, is_stub),
    ]
    return '\n'.join(shared)

### PROXY

# generate_proxy
#   - generates and saves a proxy for a given file
#   - file will be named: <prefix>.proxy.cpp
#
# args:
#   - decls [dict]: idl file contents loaded as json into a python dict
#   - prefix [str]: the prefix of the idl file
#
# returns: n/a

def generate_proxy(decls, prefix):
    pass


### STUB

# generate_badfunc
#   - generates a c++ function that handles a bad function response

def generate_badfunc(prefix):
    return (
        'void _badFunction(string funcname) {\n'
        '  int errorCode = -1;\n'
        '  c150debug->printf(\n'
        '    C150RPCDEBUG,\n'
        '    "' + prefix + '.stub: received call for nonexistent func %s()",\n'
        '    funcname.c_str()\n'
        '  );\n'
        '  RPCSTUBSOCKET->write((char *)&errorCode, sizeof(errorCode));\n'
        '}\n'
    )


# generate_stub
#   - generates and saves a stub for a given file
#   - file will be named: <prefix>.stub.cpp
#
# args:
#   - decls [dict]: idl file contents loaded as json into a python dict
#   - prefix [str]: the prefix of the idl file
#
# returns: n/a

def generate_stub(decls, prefix):
    stub_content = [
        generate_shared(prefix, True), # shared with proxy
        generate_badfunc(prefix),
    ]

    with open(prefix + '.stub.cpp', 'w+') as f:
        f.write('\n'.join(stub_content))


### GENERATE

# generate
#   - generates and saves a proxy and stub for a given file
#   - if a file does not exist or cannot be opened, an error message is printed
#     and the function terminates
#
# args:
#   - fname [str]: fname, must be of the pattern *.idl
#
# returns: n/a

def generate(fname):
    if not isfile(fname):
        print("error: '{}' does not exist or could not be opened".format(fname))
        return
    else:
        prefix = get_file_prefix(fname) # save prefix for naming things
        if not prefix:
            print("error: '{}' must be named '<prefix>.idl'".format(fname))
            return

    # parse idl declarations into python dictionary
    decls = json.loads(subprocess.check_output(["./idl_to_json", fname])
        .decode('utf-8'))

    # generate files
    generate_proxy(decls, prefix)
    generate_stub(decls, prefix)


##### MAIN

def main():
    args = parse_args()

    # temp
    for f in args.idlfiles:
        generate(f)
    # temp


if __name__ == '__main__':
    main()
